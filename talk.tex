\geometry{paperwidth=200mm,paperheight=112.5mm}
\usepackage[utf8x]{inputenc}
\usepackage{amsmath,amsfonts,amssymb}
\usefonttheme{professionalfonts}
\usepackage{fontspec}
\setsansfont{URW Gothic}
\usecolortheme{default}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{hyperref}
\hypersetup{                                                                                                                                                                                                                   
  colorlinks = true,                                                                                                                                                                                                           
  urlcolor = MidnightBlue,                                                                                                                                                                                                     
  linkcolor = black                                                                                                                                                                                                            
}
\usepackage{caption}
\usepackage{nicefrac}
\usepackage{pifont}
\usepackage{minted}
\setminted{
  bgcolor = SkyBlue!15
}
%\usepackage{wrapfig}
%\usepackage{cutwin}
% for bkblock
\usepackage[most]{tcolorbox}

\usepackage[detect-none]{siunitx}
\sisetup{range-phrase = \text{--}}

\include{commands}

%compact itemize, perfect for talks
\setlength{\leftmargin}{0pt}
\setlength{\leftmargini}{0.4cm}
\setlength{\leftmarginii}{0.2cm}

\usefonttheme{professionalfonts} 

\newcommand{\roundbox}[1]{%
\noindent\begin{tikzpicture}%
  \draw node[draw=lightgray,fill=white,rounded corners,inner sep=1ex] {%
  #1
  };%
\end{tikzpicture}%
}%

\definecolor{DarkBlue}{HTML}{002e77}
\definecolor{LightBlue}{HTML}{6495ed}
\definecolor{MidGreen}{HTML}{228b22}
\definecolor{DarkGreen}{HTML}{006400}
\definecolor{HotPink}{HTML}{dc143c}
\definecolor{LightPeach}{HTML}{ff7f50}
\definecolor{LightOrange}{HTML}{ffa500}
\definecolor{LighterOrange}{HTML}{ffcf9d}    
\definecolor{RedBrown}{HTML}{8b3e2f}
\definecolor{DarkRed}{HTML}{8b3e2f}

\usetheme{Boadilla}
\usecolortheme[named=DarkBlue]{structure}
\useinnertheme{rounded}

\setbeamertemplate{navigation symbols}{}

\graphicspath{{graphics/}}

\title[Kronos]{Kronos : A lattice QCD library accelerated with Kokkos}
\author[A. Sen, B. Kostrzewa]{Aniket Sen, Bartosz Kostrzewa  \\ \vspace{0.2cm} in collaboration with \\ \vspace{0.2cm} \centering Travis Whyte, Eric Gregory, Stefan Krieg, Giovanni Pederiva, Simon Schlepphorst}
\institute[HISKP]{HISKP \& FZJ}
\titlegraphic{\roundbox{\includegraphics[height=2.4cm]{graphics/uni_bonn_hiskp_FZJ_numeriqs_ETMC}}}
\date[ETMC meeting 2025]{\small ETMC meeting 2025, 28.08.2025}
\subject{subject}
\keywords{keywords}


\begin{document}

\begin{frame}
  \titlepage{}
\end{frame}

% \begin{frame}{Technical Overview}
%   Test
% \end{frame}

\begin{frame}{Motivation}
  \begin{itemize}
    \item Lattice QCD code for the next generation of exascale clusters
  \end{itemize} 
  \vspace{0.5cm}
  Key features: \\
  \begin{itemize}
    \item Performance portable : single architecture agnostic codebase
    \item Easy to use : reduce entry barrier for new users
  \end{itemize}


  AS: Bartek please make this slide more interesting
\end{frame}

\begin{frame}{CPUs vs GPUs}
  \centering
  \includegraphics[height=0.8\paperheight]{graphics/cpuVSgpu.png}\\
  \footnotesize{\href{https://www.frontiersin.org/journals/physics/articles/10.3389/fphy.2025.1542474/full}{[E.~Suarez, J.~Amaya, O.~Freyermuth, M.~Girone, \textbf{BK}, S.~Pfalzner, \emph{Energy efficiency trends in HPC: what high-energy and astrophycisists need to know}, Front.in Phys. 13 (2025) 1542474]}}
\end{frame}                                                    

\begin{frame}{Data Layout Matters}
  \begin{itemize}
    \item Consider an $8 \times 8$ lattice of scalar values.
    \vspace{0.1cm}
    \item Could lay out in memory as \mintinline{c++}{real[y][x]}, or when linearised, \mintinline{c++}{real[i]}, where \mintinline{c++}{i} $\in [0,63]$.
    \vspace{0.1cm}
    \item Iterate over this on CPU and GPU in some kind of \mintinline{c++}{parallel for}, spltting the work across the available threads.
  \end{itemize}
  \begin{columns}
    \column{0.5\linewidth}
      \only<1>{
        \begin{center}
          \includegraphics[height=0.6\paperheight]{graphics/grid}
        \end{center}
      }
      \only<2>{
        \begin{center}
          \includegraphics[height=0.6\paperheight]{graphics/grid_cpu}
        \end{center}
      }
      \only<3>{
        \begin{itemize}
          \item On GPU, threads are unit of vectorisation AND parallelisation.
          \vspace{0.6cm}
          \item Work is scheduled in blocks which must (ideally) be multiple of \emph{team} size.
            \begin{itemize}
              \item NVIDIA $\rightarrow$ team = warp, size 32
              \item AMD $\rightarrow$ team = wavefront, size 64
            \end{itemize}
          \vspace{0.6cm}
          \item Threads within team should access neighbouring memory locations (\emph{coalesced access}).
          \begin{itemize}
            \item Performance loss factor up to $\approx 100$ if not done! 
          \end{itemize}
        \end{itemize}
      }
    \column{0.5\linewidth}
      \only<2>{
        \begin{itemize}
          \item On CPU, ideally each thread (tX) processes a chunk of contiguous memory.
          \vspace{0.6cm}
          \item Threads operate on chunks of memory as far apart as possible.
          \vspace{0.6cm}
          \item If possible, compiler exploits SIMD unit to process multiple values in parallel per clock cycle.
          \begin{itemize}
            \item For problems with low arithmetic intensity (like lattice QCD), loss factor small if SIMD not optimally used.
          \end{itemize}
        \end{itemize}
      }
      \only<3>{
        \begin{center}
          \includegraphics[height=0.65\paperheight]{graphics/grid_gpu}
        \end{center}
      }
  \end{columns}
\end{frame}

\begin{frame}{Data Layout Matters}
  \begin{columns}
    \column{0.5\linewidth}
      \begin{center}
        \includegraphics[height=0.6\paperheight]{graphics/grid_cpu}
      \end{center}
    \column{0.5\linewidth}
      \begin{center}
        \includegraphics[height=0.65\paperheight]{graphics/grid_gpu}
      \end{center}
  \end{columns}
  \begin{itemize}
    \item Without internal structure this is more or less trivial.
  \end{itemize}
\end{frame}

\begin{frame}{Data Layout Matters}
  \begin{columns}
    \column{0.45\linewidth}
      \begin{center}
        \includegraphics[width=0.85\linewidth]{graphics/grid_su3_spinor}
      \end{center}
    \column{0.5\linewidth}
      \begin{itemize}
        \item<1-> $U(x)_\mu^{ab} \rightarrow$ \mintinline{c++}{complex[x][mu][a][b]}
        \vspace{0.2cm}
        \item<1-> $\psi(x)^{\sigma b} \rightarrow$ \mintinline{c++}{complex[x][rho][b]}
        \vspace{0.2cm}
        \begin{itemize}
          \item Consecutive lattice sites $x$ separated by e.g. \mintinline{c++}{4 * sizeof(su3)}
        \end{itemize}
        \vspace{0.6cm}
        \item<3-> \emph{Array of Struct} layout works well on CPU due to cache hierarchy and small SIMD loss factor.
        \vspace{0.6cm}
        \item<4-> On GPU would like to have $x$ running fastest:
        \vspace{0.2cm}
        \begin{itemize}
          \item \emph{Struct of Array} layout.
          \vspace{0.3cm}
          \item In C notation: $\psi(x)^{\sigma b} \rightarrow$ \mintinline{c++}{complex[rho][b][x]}
        \end{itemize}
      \end{itemize}
  \end{columns}
\end{frame}



\begin{frame}{Kokkos}
  The Kokkos C++ Performance Portability Ecosystem is a production
  level solution for writing modern C++ applications in a hardware agnostic way.\\
  
  \begin{bkblock}{Supported HPC architectures:}
    \begin{itemize}
      \item CUDA
      \item HIP
      \item SYCL
      \item HPX
      \item OpenMP
    \end{itemize}
  \end{bkblock}

  Based on concepts of:
  \begin{itemize}
    \item execution : execution space, execution pattern, execution policy
    \item memory: memory space, memory layout, memory trait
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Kokkos : Memory}{Views}
  \begin{minted}{c++}
template <class DataType [, class LayoutType] [, class MemorySpace] [, class MemoryTraits]>
class View;
  \end{minted}
  \begin{itemize}
    \item \verb|DataType| : defines the fundamental scalar type of the \verb|View| and its dimensionality
    \item \verb|LayoutType| : mapping of the indices onto the underlying 1D memory storage (\verb|LayoutRight|, \verb|LayoutLeft|)
    \item \verb|MemorySpace| : storage location of the view (device/host, related to the execution space)
    \item \verb|MemoryTraits| : access properties (\verb|Unmanaged|, \verb|RandomAccess|, ...)
  \end{itemize}

  example:
  \begin{minted}{c++}
# default layout of the execution space
using ViewLayout = Kokkos::DefaultExecutionSpace::array_layout;
# memory space of the execution space
using ViewSpace  = Kokkos::DefaultExecutionSpace::memory_space;
# a 2D view of ints with 2 dynamic extents
Kokkos::View<int**, ViewLayout, ViewSpace> a("a", 10, 12);
# a 3D view of doubles with 1 dynamic and 2 compiled extents
Kokkos::View<double*[4][3], ViewLayout, ViewSpace> b("b", 16);
  \end{minted}
\end{frame}

\begin{frame}[fragile]{Kokkos : Execution}{Policy}
  Kokkos abstracts the execution policy via

  \begin{columns}
    \column{0.4\textwidth}
      \begin{block}{RangePolicy}
        defines an execution policy for a 1D iteration space
      \end{block}
      \begin{minted}{c++}
Kokkos::RangePolicy(
  execution_space, 
  begin, end, 
  chunk_size);
      \end{minted}
    \column{0.4\textwidth}
      \begin{block}{MDRangePolcy}
        defines an execution policy for a multidimensional iteration space
      \end{block}
      \begin{minted}{c++}
Kokkos::MDRangePolicy<
  Kokkos::Rank<N>>(
    execution_space, 
    begin, end, 
    tiling);
  \end{minted}
  \end{columns}

%   \begin{itemize}
%     \item \verb|RangePolicy| : defines an execution policy for a 1D iteration space
%   \end{itemize}

%   \begin{minted}{c++}
% Kokkos::RangePolicy(execution_space, begin, end, chunk_size);
%   \end{minted}

%   \begin{itemize}
%     \item \verb|MDRangePolcy| : defines an execution policy for a multidimensional iteration space
%   \end{itemize}

%   \begin{minted}{c++}
% Kokkos::MDRangePolicy<Kokkos::Rank<N>>(execution_space, begin, end, tiling);
%   \end{minted}
  
  \begin{bkblock}{Parameters:}
    \begin{itemize}
      \item The iteration space starts at \verb|begin| and goes to \verb|end| with open interval.
      \item \verb|Rank<N>| determines the dimensionality of the multidimensional iteration space.
      \item The block sizes are controlled by \verb|chunk_size| and \verb|tiling|.
    \end{itemize}
  \end{bkblock}
\end{frame}

\begin{frame}[fragile]{Kokkos : Execution}{Parallel Dispatches}
  Kokkos executes kernels via the parallel dispatches

  \begin{itemize}
    \item \verb|parallel_for| : implements a “for loop” with independent iterations.
    \item \verb|parallel_reduce| : implements a reduction.
    \item \verb|parallel_scan| : implements a prefix scan.
  \end{itemize}

  \begin{columns}
    \column{0.45\textwidth}
      parallel\_for:
      \begin{minted}{c++}
template<
  class ExecPolicy, 
  class FunctorType>
Kokkos::parallel_for(
  const std::string &name, 
  const ExecPolicy &policy, 
  const FunctorType &functor);
      \end{minted}
    \column{0.45\textwidth}
    parallel\_reduce:
    \begin{minted}{c++}
template <
  class ExecPolicy, 
  class FunctorType, 
  class... ReducerArgument>
Kokkos::parallel_reduce(
  const std::string& name,
  const ExecPolicy& policy,
  const FunctorType& functor,
  const ReducerArgument&... reducer);
    \end{minted}
  \end{columns}
\end{frame}

\begin{frame}[fragile]{A simple kernel with Kokkos}{parallel\_for}
  \begin{columns}
    \column{0.55\textwidth}
      \begin{minted}{c++}
const int N = 16;
Kokkos::View<double*> a("a", N);
Kokkos::deep_copy(a, 2.0);
Kokkos::View<double*> b("b", N);
Kokkos::deep_copy(b, 3.0);
Kokkos::View<double*> c("c", N);
auto policy = Kokkos::RangePolicy(0, N);
Kokkos::parallel_for(
  "add",
  policy,
  KOKKOS_LAMBDA(int i) {
    c(i) = a(i) + b(i)
  }
);
Kokkos::fence();
      \end{minted}
    \column{0.4\textwidth}
      \begin{block}{c = a + b}
        \begin{itemize}
          \item initialize the 1D views
          \item \verb|deep_copy| copies the single scalar value to every site in the view
          \item Kokkos views are accessed via \verb|operator()(indices...)|
          \item the functor can be a lambda
          \item \verb|fence()| creates a barrier in the execution space
        \end{itemize}
      \end{block}
  \end{columns}
\end{frame}

\begin{frame}[fragile]{A simple kernel with Kokkos}{parallel\_reduce}
  \begin{columns}
    \column{0.55\textwidth}
      \begin{minted}{c++}
const int N1 = 16;
const int N2 = 12;
Kokkos::View<double**> a("a", N1, N2);
Kokkos::deep_copy(a, 5.0);
double sum = 0;
auto policy = Kokkos::MDRangePolicy<
                Kokkos::Rank<2>>(
                  {0, 0}, {N1, N2}
                );
Kokkos::parallel_reduce(
  "reduce_sum",
  policy,
  KOKKOS_LAMBDA(int i, int j, 
    double &lsum) {
      lsum += a(i, j);
    },
  Kokkos::Sum<double>(sum)
);
Kokkos::fence();
      \end{minted}
    \column{0.4\textwidth}
      \begin{block}{sum over a 2D view}
        \begin{itemize}
          \item similar to \verb|parallel_for|
          \item needs a local reduction variable along with the policy iteration indices
        \end{itemize}
      \end{block}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{A more general kernel using functors}
  A more generalized addition kernel for different dimensionality and site types
  \begin{columns}
    \column{0.6\textwidth}
      \begin{minted}{c++}
template <typename view_t>
struct add {
  const view_t m_a;
  const view_t m_b;
  view_t m_c;

  add(view_t &c, const view_t &a, const view_t &b) :
    m_a(a), m_b(b), m_c(c) {}
  
  template <typename... IndexTypes>
  KOKKOS_INLINE_FUNCTION
  void operator()(IndexTypes... indices) const noexcept
  {
    m_c(indices...) = m_a(indices...) + m_b(indices...)
  }
};
      \end{minted}
    \column{0.38\textwidth}
      \begin{minted}{c++}
const int N = 12;
using view_t = Kokkos::View<int*>;
view_t a("a", N);
view_t b("b", N);
view_t c("c", N);
auto add_func = add(c, a, b);
auto policy = Kokkos::RangePolicy(
                0, N
              );
Kokkos::parallel_for(
  "add_functor",
  policy,
  add_func
);
Kokkos::fence();
      \end{minted}
  \end{columns}
\end{frame}

\end{document}
